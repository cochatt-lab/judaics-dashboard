import dash
from dash import dcc, html, Input, Output, dash_table
import pandas as pd
import plotly.express as px

# Load the data (update path if needed)
df = pd.read_excel('JUDAIC-CURRICULUM-Domain_Grade_Content_-Allocation-Detail.xlsx')

# Clean data: Fill NaNs, convert Grade to string for dropdown
df['Grade'] = df['Grade'].fillna('N/A').astype(str)
df['Concepts'] = df['Concepts'].fillna('')

# Extract unique concepts/names from Column C for D dropdown (split by common terms)
def extract_concepts(content):
    if pd.isna(content):
        return []
    text = str(content).lower()
    concepts = []
    for term in ['genesis', 'bereshit', 'exodus', 'shemot', 'numbers', 'bamidbar', 'deuteronomy', 'devarim', 
                 'leviticus', 'vayikra', 'joshua', 'yehoshua', 'samuel', 'shmuel', 'kings', 'melachim', 
                 'isaiah', 'yeshayahu', 'jeremiah', 'yirmiyahu']:
        if term in text:
            concepts.append(term.title())
    return list(set(concepts))  # Unique

all_concepts = sorted(set([c for concepts in df['Content / Allocation'].apply(extract_concepts) for c in concepts]))

# Init app
app = dash.Dash(__name__)

app.layout = html.Div([
    html.H1("Judaic Curriculum Dashboard", style={'textAlign': 'center'}),
    
    # Dropdown A: Domain
    html.Label("Domain (Column A):"),
    dcc.Dropdown(
        id='domain-dropdown',
        options=[{'label': d, 'value': d} for d in sorted(df['Domain'].dropna().unique())],
        value=None,
        multi=False
    ),
    
    # Dropdown B: Grade (depends on A)
    html.Label("Grade (Column B):"),
    dcc.Dropdown(id='grade-dropdown', value=None),
    
    # Dropdown C: Content (populated after B)
    html.Label("Content (Column C):"),
    dcc.Dropdown(id='content-dropdown', value=None),
    
    # Dropdown D: Concepts (from C extraction + original)
    html.Label("Concepts (Column D):"),
    dcc.Dropdown(id='concepts-dropdown', options=[{'label': c, 'value': c} for c in all_concepts], value=None, multi=True),
    
    # Dropdowns E-H
    html.Label("JSAT (Column E):"), dcc.Dropdown(id='jsat-dropdown', multi=True),
    html.Label("ELA (Column F):"), dcc.Dropdown(id='ela-dropdown', multi=True),
    html.Label("History/Geography (Column G):"), dcc.Dropdown(id='hist-dropdown', multi=True),
    html.Label("Hebrew (Column H):"), dcc.Dropdown(id='hebrew-dropdown', multi=True),
    
    # Filtered table
    dash_table.DataTable(id='table', page_size=10),
    
    # Summary chart
    dcc.Graph(id='chart')
])

# Callback: Update B based on A
@app.callback(
    Output('grade-dropdown', 'options'),
    Input('domain-dropdown', 'value')
)
def update_grade(domain):
    if domain is None:
        return []
    filtered = df[df['Domain'] == domain]
    return [{'label': g, 'value': g} for g in sorted(filtered['Grade'].unique())]

# Update C based on B
@app.callback(
    Output('content-dropdown', 'options'),
    [Input('domain-dropdown', 'value'), Input('grade-dropdown', 'value')]
)
def update_content(domain, grade):
    if domain is None or grade is None:
        return []
    filtered = df[(df['Domain'] == domain) & (df['Grade'].astype(str) == grade)]
    return [{'label': str(c), 'value': str(c)} for c in filtered['Content / Allocation'].unique()]

# Update E-H options based on prior + concepts
@app.callback(
    [Output('jsat-dropdown', 'options'),
     Output('ela-dropdown', 'options'),
     Output('hist-dropdown', 'options'),
     Output('hebrew-dropdown', 'options')],
    [Input('domain-dropdown', 'value'),
     Input('grade-dropdown', 'value'),
     Input('content-dropdown', 'value'),
     Input('concepts-dropdown', 'value')]
)
def update_eh_options(domain, grade, content, concepts):
    if domain is None:
        return [], [], [], []
    mask = df['Domain'] == domain
    if grade: mask &= df['Grade'].astype(str) == grade
    if content: mask &= df['Content / Allocation'].astype(str) == content
    if concepts:
        mask &= df['Content / Allocation'].apply(lambda x: any(c.lower() in str(x).lower() for c in concepts))
    filtered = df[mask]
    opts = lambda col: [{'label': str(v), 'value': str(v)} for v in filtered[col].dropna().unique()]
    return (opts('JSAT benchmarks'), opts('ELA benchmarks'), opts('History and Geography benchmarks'), opts('Hebrew Language benchmarks ????'))

# Filtered table and chart
@app.callback(
    [Output('table', 'data'), Output('table', 'columns'), Output('chart', 'figure')],
    [Input('domain-dropdown', 'value'),
     Input('grade-dropdown', 'value'),
     Input('content-dropdown', 'value'),
     Input('concepts-dropdown', 'value'),
     Input('jsat-dropdown', 'value'),
     Input('ela-dropdown', 'value'),
     Input('hist-dropdown', 'value'),
     Input('hebrew-dropdown', 'value')]
)
def update_dashboard(domain, grade, content, concepts, jsat, ela, hist, hebrew):
    mask = pd.Series([True] * len(df), index=df.index)
    if domain: mask &= df['Domain'] == domain
    if grade: mask &= df['Grade'].astype(str) == grade
    if content: mask &= df['Content / Allocation'].astype(str) == content
    if concepts:
        mask &= df['Content / Allocation'].apply(lambda x: any(c.lower() in str(x).lower() for c in concepts))
    if jsat: mask &= df['JSAT benchmarks'].astype(str).isin(jsat)
    if ela: mask &= df['ELA benchmarks'].astype(str).isin(ela)
    if hist: mask &= df['History and Geography benchmarks'].astype(str).isin(hist)
    if hebrew: mask &= df['Hebrew Language benchmarks ????'].astype(str).isin(hebrew)
    
    filtered_df = df[mask]
    columns = [{"name": i, "id": i} for i in df.columns]
    fig = px.bar(filtered_df, x='Grade', color='Domain', title='Filtered Records by Grade') if not filtered_df.empty else px.bar(title='No Data')
    
    return filtered_df.to_dict('records'), columns, fig

if __name__ == '__main__':
    app.run_server(debug=True)
